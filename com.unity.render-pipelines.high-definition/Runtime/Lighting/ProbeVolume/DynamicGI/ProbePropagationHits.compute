#pragma multi_compile _ COMPUTE_INFINITE_BOUNCE
#pragma multi_compile _ PREVIOUS_RADIANCE_CACHE_INVALID

#pragma kernel AccumulateLightingDirectional
#define GROUP_SIZE 64
//#pragma enable_d3d11_debug_symbols

#pragma multi_compile BASIS_SPHERICAL_GAUSSIAN BASIS_SPHERICAL_GAUSSIAN_WINDOWED BASIS_AMBIENT_DICE_SHARP BASIS_AMBIENT_DICE_SOFTER BASIS_AMBIENT_DICE_SUPER_SOFT BASIS_AMBIENT_DICE_ULTRA_SOFT
#pragma multi_compile BASIS_PROPAGATION_OVERRIDE_NONE BASIS_PROPAGATION_OVERRIDE_SPHERICAL_GAUSSIAN BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_SOFTER BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_SUPER_SOFT BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_ULTRA_SOFT

#define SHADOW_MINIMAL
#define LIGHT_EVALUATION_NO_HEIGHT_FOG
#define DEBUGGING 0
#define SUPPORTS_AREA_LIGHTS 1

#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagation.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationBasis.hlsl"

RWStructuredBuffer<float3> _HitRadianceCacheAxis;
int _HitRadianceCacheAxisCount;

StructuredBuffer<PackedNeighborHit> _ProbeVolumeNeighborHits;
int _ProbeVolumeNeighborHitCount;

float4 _RayAxis[NEIGHBOR_AXIS_COUNT];

float _IndirectScale;
float _MaxAlbedo;
float _BakedEmissionMultiplier;
float _MixedLightingMultiplier;
int _MixedLightsAsRealtimeEnabled;
float _RayBias;
float _InfiniteBounce;
float _Sharpness;

float _ProbeVolumeDGIMaxNeighborDistance;
uint _ProbeVolumeDGIResolutionXY;
uint _ProbeVolumeDGIResolutionX;
float3 _ProbeVolumeDGIResolutionInverse;

float3 _ProbeVolumeDGIBoundsRight;
float3 _ProbeVolumeDGIBoundsUp;
float3 _ProbeVolumeDGIBoundsExtents;
float3 _ProbeVolumeDGIBoundsCenter;


StructuredBuffer<LightData> _DynamicGILightDatas;
uint _DynamicGIPunctualLightCount;
uint _DynamicGIAreaLightCount;

float _RangeInFrontOfCamera;
float _RangeBehindCamera;

// -------------------------------------------------------------
// Actual Light Loop
// -------------------------------------------------------------

// Fixes strobing when punctual lights are too close to surfaces
float3 BiasLightPositionNearHit(float3 lightPosition, float3 hitPosition)
{
    const float minimumDistance = 0.75f;

    float3 vec = hitPosition - lightPosition;
    float dist = length(vec);
    float pushDistance = dist < minimumDistance ? dist - minimumDistance : 0;

    return normalize(vec) * pushDistance;
}

bool CheckMixedLight(bool mixedDynamicGI)
{
    return _MixedLightsAsRealtimeEnabled || !mixedDynamicGI;
}

float3 EvaluateDirectLightingAtHit(SurfaceHitData hit)
{
    LightData light;
    float3 directLighting = 0;

    // Punctual
    for (uint puncLightIdx = 0; puncLightIdx < _DynamicGIPunctualLightCount; ++puncLightIdx)
    {
        light = _DynamicGILightDatas[puncLightIdx];
        if (CheckMixedLight(light.mixedDynamicGI))
        {
            light.positionRWS += BiasLightPositionNearHit(light.positionRWS, GetCameraRelativePositionWS(hit.position));
            directLighting += GetLightingForAxisPunctual(light, _IndirectScale, hit);
        }
    }

#if SUPPORTS_AREA_LIGHTS
    // Area lights
    int lastAreaLightIndex = _DynamicGIPunctualLightCount + _DynamicGIAreaLightCount;
    for (uint areaLightIdx = (uint)_DynamicGIPunctualLightCount; areaLightIdx < (uint)lastAreaLightIndex; ++areaLightIdx)
    {
        light = _DynamicGILightDatas[areaLightIdx];
        if (CheckMixedLight(light.mixedDynamicGI))
            directLighting += GetLightingForAxisArea(light, _IndirectScale, hit);
    }
#endif

    // Directional
    for (uint dirLightIdx = 0; dirLightIdx < (uint)_DirectionalLightCount; ++dirLightIdx)
    {
        DirectionalLightData dirData = _DirectionalLightDatas[dirLightIdx];
        // Only support the shadow casting one otherwise result is completely off.
        if (dirData.affectDynamicGI && CheckMixedLight(dirData.mixedDynamicGI) && _DirectionalShadowIndex == (int)dirLightIdx)
            directLighting += GetLightingForAxisDirectional(dirData, _IndirectScale * dirData.bounceIntensity, hit);
    }

    return directLighting;
}

float3 EvaluateBRDFLambertApproximate(uint probeIndex, float3 surfaceNormal, float sharpness, in float4 _RayAxis[NEIGHBOR_AXIS_COUNT])
{
    float3 color = 0;
    for(int i=0; i < NEIGHBOR_AXIS_COUNT; ++i)
    {
        float3 prevAxisRadiance = ReadPreviousPropagationAxis(probeIndex, i);
        float3 axis = _RayAxis[i].xyz;

        BasisAxisHit basisAxisHit = ComputeBasisAxisHit(axis, sharpness);

        float integral = ComputeBasisAxisHitAndClampedCosineProductIntegral(basisAxisHit, surfaceNormal);

        color += prevAxisRadiance * integral;
    }

    return color;
}

float3 EstimateIncomingBounceLightAtHit(uint probeIndex, SurfaceHitData hit)
{
    #if defined(PREVIOUS_RADIANCE_CACHE_INVALID)
        return 0;
    #else
        const float maxAlbedoChannel = max(max(hit.albedo.r, hit.albedo.g), hit.albedo.b);
        const float3 infiniteBounceAlbedo = maxAlbedoChannel > _MaxAlbedo ? hit.albedo * _MaxAlbedo / maxAlbedoChannel : hit.albedo;

        float3 incomingIrradiance = EvaluateBRDFLambertApproximate(probeIndex, hit.normal, _Sharpness, _RayAxis);
        incomingIrradiance *= _InfiniteBounce;
        incomingIrradiance *= infiniteBounceAlbedo;

        return incomingIrradiance;
    #endif
}

float3 ProbeIndexToProbeCoordinates(uint probeIndex)
{
    uint probeZ = probeIndex / _ProbeVolumeDGIResolutionXY;
    probeIndex -= probeZ * _ProbeVolumeDGIResolutionXY;

    uint probeY = probeIndex / _ProbeVolumeDGIResolutionX;
    uint probeX = probeIndex % _ProbeVolumeDGIResolutionX;

    return float3(probeX, probeY, probeZ) + 0.5;
}

float3 ProbeCoordinatesToWorldPosition(float3 probeCoordinates, float3x3 probeVolumeLtw)
{
    float3 localPosition = ((probeCoordinates * _ProbeVolumeDGIResolutionInverse) * 2.0 - 1.0) * _ProbeVolumeDGIBoundsExtents;
    return mul(localPosition, probeVolumeLtw) + GetAbsolutePositionWS(_ProbeVolumeDGIBoundsCenter);
}

SurfaceHitData ConstructSurfaceHit(PackedNeighborHit neighborData, float3 worldPosition, float3x3 probeVolumeLtw)
{
    float4 albedoDistance = UnpackAlbedoAndDistance(neighborData.albedoDistance, _ProbeVolumeDGIMaxNeighborDistance);
    float3 axis = UnpackAxis(neighborData.normalAxis).xyz;

    axis = mul(axis, probeVolumeLtw);

    SurfaceHitData hit;
    hit.normal = UnpackNormal(neighborData.normalAxis);
    hit.normal = mul(hit.normal, probeVolumeLtw);
    hit.albedo = albedoDistance.xyz;

    float3 hitPosition = worldPosition;
    hitPosition += axis * albedoDistance.w;
    hitPosition += hit.normal * _RayBias;
    hit.position = hitPosition;

    return hit;
}


[numthreads(GROUP_SIZE, 1, 1)]
void AccumulateLightingDirectional(uint3 id : SV_DispatchThreadID)
{
    const int hitAxisIndex = id.x;
    if (hitAxisIndex < _ProbeVolumeNeighborHitCount)
    {
        PackedNeighborHit neighborData = _ProbeVolumeNeighborHits[hitAxisIndex];

        uint probeIndex, axisIndex;
        float probeValidity;
        UnpackIndicesAndValidity(neighborData.indexValidity, probeIndex, axisIndex, probeValidity);

        const float3x3 probeVolumeLtw = float3x3(_ProbeVolumeDGIBoundsRight, _ProbeVolumeDGIBoundsUp, cross(_ProbeVolumeDGIBoundsRight, _ProbeVolumeDGIBoundsUp));
        const float3 probeCoordinate = ProbeIndexToProbeCoordinates(probeIndex);
        const float3 worldPosition =  ProbeCoordinatesToWorldPosition(probeCoordinate, probeVolumeLtw);

        // Early out at far distances
        if (IsFarFromCamera(worldPosition, _RangeInFrontOfCamera, _RangeBehindCamera))
        {
            return;
        }

        const SurfaceHitData hit = ConstructSurfaceHit(neighborData, worldPosition, probeVolumeLtw);

        #if defined(COMPUTE_INFINITE_BOUNCE)
            float3 lighting = EstimateIncomingBounceLightAtHit(probeIndex, hit) * InvalidScale(probeValidity);
        #else
            float3 lighting = 0;
        #endif

        lighting += EvaluateDirectLightingAtHit(hit);

        lighting += UnpackEmission(neighborData.emission) * _BakedEmissionMultiplier;
        lighting += UnpackEmission(neighborData.mixedLighting) * _MixedLightingMultiplier;

        _HitRadianceCacheAxis[hitAxisIndex] = lighting;
    }
}
